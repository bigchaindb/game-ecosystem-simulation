{"remainingRequest":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/utils/extractJson.js","dependencies":[{"path":"/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/utils/extractJson.js","mtime":1517179453000},{"path":"/Users/jpregelj/eots/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var ascii = require(\"./asciiToTrytes\");\nvar inputValidator = require(\"./inputValidator\");\n\n/**\n*   extractJson takes a bundle as input and from the signatureMessageFragments extracts the correct JSON\n*   data which was encoded and sent with the transaction.\n*\n*   @method extractJson\n*   @param {array} bundle\n*   @returns {Object}\n**/\nfunction extractJson(bundle) {\n\n    // if wrong input return null\n    if ( !inputValidator.isArray(bundle) || bundle[0] === undefined ) return null;\n\n\n    // Sanity check: if the first tryte pair is not opening bracket, it's not a message\n    var firstTrytePair = bundle[0].signatureMessageFragment[0] + bundle[0].signatureMessageFragment[1];\n\n    if (firstTrytePair !== \"OD\") return null;\n\n    var index = 0;\n    var notEnded = true;\n    var trytesChunk = '';\n    var trytesChecked = 0;\n    var preliminaryStop = false;\n    var finalJson = '';\n\n    while (index < bundle.length && notEnded) {\n\n        var messageChunk = bundle[index].signatureMessageFragment;\n\n        // We iterate over the message chunk, reading 9 trytes at a time\n        for (var i = 0; i < messageChunk.length; i += 9) {\n\n            // get 9 trytes\n            var trytes = messageChunk.slice(i, i + 9);\n            trytesChunk += trytes;\n\n            // Get the upper limit of the tytes that need to be checked\n            // because we only check 2 trytes at a time, there is sometimes a leftover\n            var upperLimit = trytesChunk.length - trytesChunk.length % 2;\n\n            var trytesToCheck = trytesChunk.slice(trytesChecked, upperLimit);\n\n            // We read 2 trytes at a time and check if it equals the closing bracket character\n            for (var j = 0; j < trytesToCheck.length; j += 2) {\n\n                var trytePair = trytesToCheck[j] + trytesToCheck[j + 1];\n\n                // If closing bracket char was found, and there are only trailing 9's\n                // we quit and remove the 9's from the trytesChunk.\n                if ( preliminaryStop && trytePair === '99' ) {\n\n                    notEnded = false;\n                    // TODO: Remove the trailing 9's from trytesChunk\n                    //var closingBracket = trytesToCheck.indexOf('QD') + 1;\n\n                    //trytesChunk = trytesChunk.slice( 0, ( trytesChunk.length - trytesToCheck.length ) + ( closingBracket % 2 === 0 ? closingBracket : closingBracket + 1 ) );\n\n                    break;\n                }\n\n                finalJson += ascii.fromTrytes(trytePair);\n\n                // If tryte pair equals closing bracket char, we set a preliminary stop\n                // the preliminaryStop is useful when we have a nested JSON object\n                if (trytePair === \"QD\") {\n                    preliminaryStop = true;\n                }\n            }\n\n            if (!notEnded)\n                break;\n\n            trytesChecked += trytesToCheck.length;\n        }\n\n        // If we have not reached the end of the message yet, we continue with the next\n        // transaction in the bundle\n        index += 1;\n\n    }\n\n    // If we did not find any JSON, return null\n    if (notEnded) {\n\n        return null;\n\n    } else {\n\n        return finalJson;\n\n    }\n}\n\nmodule.exports = extractJson;\n",null]}