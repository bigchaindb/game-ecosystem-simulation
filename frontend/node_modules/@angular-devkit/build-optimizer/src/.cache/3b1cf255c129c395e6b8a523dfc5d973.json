{"remainingRequest":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/crypto/bundle/bundle.js","dependencies":[{"path":"/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/crypto/bundle/bundle.js","mtime":1517179453000},{"path":"/Users/jpregelj/eots/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var Curl = require(\"../curl/curl\");\nvar Kerl = require(\"../kerl/kerl\");\nvar Converter = require(\"../converter/converter\");\nvar tritAdd = require(\"../helpers/adder\");\n\n/**\n*\n*   @constructor bundle\n**/\nfunction Bundle() {\n\n    // Declare empty bundle\n    this.bundle = [];\n}\n\n/**\n*\n*\n**/\n\nBundle.prototype.addEntry = function(signatureMessageLength, address, value, tag, timestamp, index) {\n\n    for (var i = 0; i < signatureMessageLength; i++) {\n\n        var transactionObject = new Object();\n        transactionObject.address = address;\n        transactionObject.value = i == 0 ? value : 0;\n        transactionObject.obsoleteTag = tag;\n        transactionObject.tag = tag;\n        transactionObject.timestamp = timestamp;\n\n        this.bundle[this.bundle.length] = transactionObject;\n    }\n}\n\n/**\n*\n*\n**/\nBundle.prototype.addTrytes = function(signatureFragments) {\n\n    var emptySignatureFragment = '';\n    var emptyHash = '999999999999999999999999999999999999999999999999999999999999999999999999999999999';\n    var emptyTag = '9'.repeat(27);\n    var emptyTimestamp = '9'.repeat(9);\n\n    for (var j = 0; emptySignatureFragment.length < 2187; j++) {\n        emptySignatureFragment += '9';\n    }\n\n    for (var i = 0; i < this.bundle.length; i++) {\n\n        // Fill empty signatureMessageFragment\n        this.bundle[i].signatureMessageFragment = signatureFragments[i] ? signatureFragments[i] : emptySignatureFragment;\n\n        // Fill empty trunkTransaction\n        this.bundle[i].trunkTransaction = emptyHash;\n\n        // Fill empty branchTransaction\n        this.bundle[i].branchTransaction = emptyHash;\n\n        this.bundle[i].attachmentTimestamp = emptyTimestamp;\n        this.bundle[i].attachmentTimestampLowerBound = emptyTimestamp;\n        this.bundle[i].attachmentTimestampUpperBound = emptyTimestamp;\n        // Fill empty nonce\n        this.bundle[i].nonce = emptyTag;\n    }\n}\n\n\n/**\n*\n*\n**/\nBundle.prototype.finalize = function() {\n    var validBundle = false;\n\n  while(!validBundle) {\n\n    var kerl = new Kerl();\n    kerl.initialize();\n\n    for (var i = 0; i < this.bundle.length; i++) {\n\n        var valueTrits = Converter.trits(this.bundle[i].value);\n        while (valueTrits.length < 81) {\n            valueTrits[valueTrits.length] = 0;\n        }\n\n        var timestampTrits = Converter.trits(this.bundle[i].timestamp);\n        while (timestampTrits.length < 27) {\n            timestampTrits[timestampTrits.length] = 0;\n        }\n\n        var currentIndexTrits = Converter.trits(this.bundle[i].currentIndex = i);\n        while (currentIndexTrits.length < 27) {\n            currentIndexTrits[currentIndexTrits.length] = 0;\n        }\n\n        var lastIndexTrits = Converter.trits(this.bundle[i].lastIndex = this.bundle.length - 1);\n        while (lastIndexTrits.length < 27) {\n            lastIndexTrits[lastIndexTrits.length] = 0;\n        }\n\n        var bundleEssence = Converter.trits(this.bundle[i].address + Converter.trytes(valueTrits) + this.bundle[i].obsoleteTag + Converter.trytes(timestampTrits) + Converter.trytes(currentIndexTrits) + Converter.trytes(lastIndexTrits));\n        kerl.absorb(bundleEssence, 0, bundleEssence.length);\n    }\n\n    var hash = [];\n    kerl.squeeze(hash, 0, Curl.HASH_LENGTH);\n    hash = Converter.trytes(hash);\n\n    for (var i = 0; i < this.bundle.length; i++) {\n\n        this.bundle[i].bundle = hash;\n    }\n\n    var normalizedHash = this.normalizedBundle(hash);\n    if(normalizedHash.indexOf(13 /* = M */) != -1) {\n      // Insecure bundle. Increment Tag and recompute bundle hash.\n      var increasedTag = tritAdd(Converter.trits(this.bundle[0].obsoleteTag), [1]);\n      this.bundle[0].obsoleteTag = Converter.trytes(increasedTag);\n    } else {\n      validBundle = true;\n    }\n  }\n}\n\n/**\n*   Normalizes the bundle hash\n*\n**/\nBundle.prototype.normalizedBundle = function(bundleHash) {\n\n    var normalizedBundle = [];\n\n    for (var i = 0; i < 3; i++) {\n\n        var sum = 0;\n        for (var j = 0; j < 27; j++) {\n\n            sum += (normalizedBundle[i * 27 + j] = Converter.value(Converter.trits(bundleHash.charAt(i * 27 + j))));\n        }\n\n        if (sum >= 0) {\n\n            while (sum-- > 0) {\n\n                for (var j = 0; j < 27; j++) {\n\n                    if (normalizedBundle[i * 27 + j] > -13) {\n\n                        normalizedBundle[i * 27 + j]--;\n                        break;\n                    }\n                }\n            }\n        } else {\n\n            while (sum++ < 0) {\n\n                for (var j = 0; j < 27; j++) {\n\n                    if (normalizedBundle[i * 27 + j] < 13) {\n\n                        normalizedBundle[i * 27 + j]++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    return normalizedBundle;\n}\n\nmodule.exports = Bundle;\n",null]}