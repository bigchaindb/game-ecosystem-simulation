{"remainingRequest":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/crypto/converter/words.js","dependencies":[{"path":"/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/crypto/converter/words.js","mtime":1517179453000},{"path":"/Users/jpregelj/eots/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var INT_LENGTH = 12;\nvar BYTE_LENGTH = 48;\nvar RADIX = 3;\n/// hex representation of (3^242)/2\nvar HALF_3 = new Uint32Array([\n    0xa5ce8964,\n    0x9f007669,\n    0x1484504f,\n    0x3ade00d9,\n    0x0c24486e,\n    0x50979d57,\n    0x79a4c702,\n    0x48bbae36,\n    0xa9f6808b,\n    0xaa06a805,\n    0xa87fabdf,\n    0x5e69ebef\n]);\n\nvar clone_uint32Array = function(array) {\n  var source = new Uint32Array(array);\n\n  return new Uint32Array(source);\n};\n\nvar ta_slice = function(array) {\n  if (array.slice !== undefined) {\n      return array.slice();\n  }\n\n  return clone_uint32Array(array);\n};\n\nvar ta_reverse = function(array) {\n  if (array.reverse !== undefined) {\n    array.reverse();\n    return;\n  }\n\n  var i = 0,\n    n = array.length,\n    middle = Math.floor(n / 2),\n    temp = null;\n\n  for (; i < middle; i += 1) {\n    temp = array[i];\n    array[i] = array[n - 1 - i];\n    array[n - 1 - i] = temp;\n  }\n};\n\n/// negates the (unsigned) input array\nvar bigint_not = function(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = (~arr[i]) >>> 0;\n    }\n};\n\n/// rshift that works with up to 53\n/// JS's shift operators only work on 32 bit integers\n/// ours is up to 33 or 34 bits though, so\n/// we need to implement shifting manually\nvar rshift = function(number, shift) {\n    return (number / Math.pow(2, shift)) >>> 0;\n};\n\n/// swaps endianness\nvar swap32 = function(val) {\n    return ((val & 0xFF) << 24) |\n        ((val & 0xFF00) << 8) |\n        ((val >> 8) & 0xFF00) |\n        ((val >> 24) & 0xFF);\n}\n\n/// add with carry\nvar full_add = function(lh, rh, carry) {\n    var v = lh + rh;\n    var l = (rshift(v, 32)) & 0xFFFFFFFF;\n    var r = (v & 0xFFFFFFFF) >>> 0;\n    var carry1 = l != 0;\n\n    if (carry) {\n        v = r + 1;\n    }\n    l = (rshift(v, 32)) & 0xFFFFFFFF;\n    r = (v & 0xFFFFFFFF) >>> 0;\n    var carry2 = l != 0;\n\n    return [r, carry1 || carry2];\n};\n\n/// subtracts rh from base\nvar bigint_sub = function(base, rh) {\n    var noborrow = true;\n\n    for (var i = 0; i < base.length; i++) {\n        var vc = full_add(base[i], (~rh[i] >>> 0), noborrow);\n        base[i] = vc[0];\n        noborrow = vc[1];\n    }\n\n    if (!noborrow) {\n        throw \"noborrow\";\n    }\n};\n\n/// compares two (unsigned) big integers\nvar bigint_cmp = function(lh, rh) {\n    for (var i = lh.length; i-- > 0;) {\n        var a = lh[i] >>> 0;\n        var b = rh[i] >>> 0;\n        if (a < b) {\n            return -1;\n        } else if (a > b) {\n            return 1;\n        }\n    }\n    return 0;\n};\n\n/// adds rh to base in place\nvar bigint_add = function(base, rh) {\n    var carry = false;\n    for (var i = 0; i < base.length; i++) {\n        var vc = full_add(base[i], rh[i], carry);\n        base[i] = vc[0];\n        carry = vc[1];\n    }\n};\n\n/// adds a small (i.e. <32bit) number to base\nvar bigint_add_small = function(base, other) {\n    var vc = full_add(base[0], other, false);\n    base[0] = vc[0];\n    var carry = vc[1];\n\n    var i = 1;\n    while (carry && i < base.length) {\n        var vc = full_add(base[i], 0, carry);\n        base[i] = vc[0];\n        carry = vc[1];\n        i += 1;\n    }\n\n    return i;\n};\n\n/// converts the given byte array to trits\nvar words_to_trits = function(words) {\n    if (words.length != INT_LENGTH) {\n        throw \"Invalid words length\";\n    }\n\n    var trits = new Int8Array(243);\n    var base = new Uint32Array(words);\n\n    ta_reverse(base);\n\n    var flip_trits = false;\n    if (base[INT_LENGTH - 1] >> 31 == 0) {\n        // positive two's complement number.\n        // add HALF_3 to move it to the right place.\n        bigint_add(base, HALF_3);\n    } else {\n        // negative number.\n        bigint_not(base);\n        if (bigint_cmp(base, HALF_3) > 0) {\n            bigint_sub(base, HALF_3);\n            flip_trits = true;\n        } else {\n            /// bigint is between (unsigned) HALF_3 and (2**384 - 3**242/2).\n            bigint_add_small(base, 1);\n            var tmp = ta_slice(HALF_3);\n            bigint_sub(tmp, base);\n            base = tmp;\n        }\n    }\n\n\n    var rem = 0;\n\n    for (var i = 0; i < 242; i++) {\n        rem = 0;\n        for (var j = INT_LENGTH - 1; j >= 0; j--) {\n            var lhs = (rem != 0 ? rem * 0xFFFFFFFF + rem : 0) + base[j];\n            var rhs = RADIX;\n\n            var q = (lhs / rhs) >>> 0;\n            var r = (lhs % rhs) >>> 0;\n\n            base[j] = q;\n            rem = r;\n        }\n\n        trits[i] = rem - 1;\n    }\n\n    if (flip_trits) {\n        for (var i = 0; i < trits.length; i++) {\n            trits[i] = -trits[i];\n        }\n    }\n\n    return trits;\n}\n\nvar is_null = function(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] != 0) {\n            return false;\n            break;\n        }\n    }\n    return true;\n}\n\nvar trits_to_words = function(trits) {\n    if (trits.length != 243) {\n        throw \"Invalid trits length\";\n    }\n\n    var base = new Uint32Array(INT_LENGTH);\n\n    if (trits.slice(0, 242).every(function(a) {\n            a == -1\n        })) {\n        base = ta_slice(HALF_3);\n        bigint_not(base);\n        bigint_add_small(base, 1);\n    } else {\n        var size = 1;\n        for (var i = trits.length - 1; i-- > 0;) {\n            var trit = trits[i] + 1;\n\n            //multiply by radix\n            {\n                var sz = size;\n                var carry = 0;\n\n                for (var j = 0; j < sz; j++) {\n                    var v = base[j] * RADIX + carry;\n                    carry = rshift(v, 32);\n                    base[j] = (v & 0xFFFFFFFF) >>> 0;\n                }\n\n                if (carry > 0) {\n                    base[sz] = carry;\n                    size += 1;\n                }\n            }\n\n            //addition\n            {\n                var sz = bigint_add_small(base, trit);\n                if (sz > size) {\n                    size = sz;\n                }\n            }\n        }\n\n        if (!is_null(base)) {\n            if (bigint_cmp(HALF_3, base) <= 0) {\n                // base >= HALF_3\n                // just do base - HALF_3\n                bigint_sub(base, HALF_3);\n            } else {\n                // base < HALF_3\n                // so we need to transform it to a two's complement representation\n                // of (base - HALF_3).\n                // as we don't have a wrapping (-), we need to use some bit magic\n                var tmp = ta_slice(HALF_3);\n                bigint_sub(tmp, base);\n                bigint_not(tmp);\n                bigint_add_small(tmp, 1);\n                base = tmp;\n            }\n        }\n    }\n\n    ta_reverse(base);\n\n    for (var i = 0; i < base.length; i++) {\n        base[i] = swap32(base[i]);\n    }\n\n    return base;\n};\n\nmodule.exports = {\n    trits_to_words: trits_to_words,\n    words_to_trits: words_to_trits\n};\n",null]}