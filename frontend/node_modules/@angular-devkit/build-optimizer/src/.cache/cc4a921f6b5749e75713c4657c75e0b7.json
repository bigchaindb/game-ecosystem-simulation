{"remainingRequest":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/utils/makeRequest.js","dependencies":[{"path":"/Users/jpregelj/eots/frontend/node_modules/iota.lib.js/lib/utils/makeRequest.js","mtime":1517179453000},{"path":"/Users/jpregelj/eots/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/jpregelj/eots/frontend/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var async = require(\"async\");\nvar errors = require(\"../errors/requestErrors\");\n\nfunction xmlHttpRequest() {\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return new XMLHttpRequest();\n  }\n  pretendingNotToRequire = require;\n  var module = 'xmlhttprequest';\n  var request = pretendingNotToRequire(module).XMLHttpRequest;\n  return new request();\n}\n\nfunction makeRequest(provider, token) {\n\n    this.provider = provider || \"http://localhost:14265\";\n    this.token = token;\n}\n\n/**\n*   Change the HTTP provider\n*\n*   @method setProvider\n*   @param {String} provider\n**/\nmakeRequest.prototype.setProvider = function(provider) {\n\n    this.provider = provider || \"http://localhost:14265\";\n}\n\n/**\n*   creates an XMLHttpRequest Object\n*\n*   @method open\n*   @param {object} command\n*   @returns {object} request\n**/\nmakeRequest.prototype.open = function() {\n\n    var request = xmlHttpRequest();\n    request.open('POST', this.provider, true);\n    request.setRequestHeader('Content-Type','application/json');\n    request.setRequestHeader('X-IOTA-API-Version', '1');\n\n    if (this.token) {\n        //request.withCredentials = true;\n        request.setRequestHeader('Authorization', 'token ' + this.token);\n    }\n\n    return request;\n}\n\n/**\n*   sends an http request to a specified host\n*\n*   @method send\n*   @param {object} command\n*   @param {function} callback\n**/\nmakeRequest.prototype.send = function(command, callback) {\n\n    var self = this;\n    var request = this.open();\n\n    request.onreadystatechange = function() {\n\n        if (request.readyState === 4) {\n\n            var result = request.responseText;\n            // Prepare the result\n            return self.prepareResult(result, command.command, callback);\n        }\n    }\n\n    try {\n\n        request.send(JSON.stringify(command));\n    } catch(error) {\n\n        return callback(errors.invalidResponse(error));\n    }\n}\n\n/**\n*   sends a batched http request to a specified host\n*   supports findTransactions, getBalances, getInclusionStates & getTrytes commands\n*\n*   @method batchedSend\n*   @param {object} command\n*   @param {function} callback\n**/\nmakeRequest.prototype.batchedSend = function (command, keys, batchSize, callback) {\n  var self = this\n  var requestStack = []\n\n  keys.forEach(function (key) {\n    while (command[key].length) {\n      var batch = command[key].splice(0, batchSize)\n      var params = {}\n\n      Object.keys(command).forEach(function (k) {\n        if (k === key || keys.indexOf(k) === -1) {\n          params[k] = k === key ? batch : command[k]\n        }\n      })\n\n      requestStack.push(params)\n    }\n  })\n\n  async.mapSeries(requestStack, function (command, cb) {\n    self.send(command, function (err, res) {\n      if (err) {\n        return cb(err)\n      }\n\n      cb(null, res)\n    })\n  }, function (err, res) {\n    if (err) {\n      return callback(err)\n    }\n\n    switch (command.command) {\n      case 'getBalances':\n        var balances = res.reduce(function (a, b) {\n          return a.concat(b.balances)\n        }, [])\n\n        res = res.sort(function (a, b) {\n          return a.milestoneIndex - b.milestoneIndex\n        }).shift()\n\n        res.balances = balances\n\n        callback(null, res)\n\n        break\n\n      case 'findTransactions':\n        var seenTxs = new Set()\n\n        if (keys.length === 1) {\n          return callback(null, res.reduce(function (a, b) {\n            return a.concat(b)\n          }, []).filter(function (tx) {\n            var seen = seenTxs.has(tx.hash)\n\n            if (!seen) {\n              seenTxs.add(tx.hash)\n\n              return true\n            }\n\n            return false\n          }))\n        }\n\n        var keysToTxFields = {\n          'bundles': 'bundle',\n          'addresses': 'address',\n          'hashes': 'hash',\n          'tags': 'tag'\n        }\n\n        callback(null, res.map(function (batch) {\n          return batch.filter(function (tx) {\n            return keys.every(function (key) {\n              return requestStack.some(function (command) {\n                return command.hasOwnProperty(key) &&\n                  command[key].findIndex(function (value) {\n                    return value === tx[keysToTxFields[key]]\n                  }) !== -1\n              })\n            })\n          })\n        }).reduce(function (a, b) {\n          return a.concat(b)\n        }, []).filter(function (tx) {\n          if (!seenTxs.has(tx.hash)) {\n            seenTxs.add(tx.hash)\n\n            return true\n          }\n          return false\n        }))\n\n        break\n\n      default:\n        callback(null, res.reduce(function (a, b) {\n          return a.concat(b)\n        }, []))\n    }\n  })\n}\n\n/**\n*   sends an http request to a specified host\n*\n*   @method sandboxSend\n*   @param {object} command\n*   @param {function} callback\n**/\nmakeRequest.prototype.sandboxSend = function(job, callback) {\n\n    // Check every 15 seconds if the job finished or not\n    // If failed, return error\n\n    var newInterval = setInterval(function() {\n\n        var request = xmlHttpRequest();\n\n        request.onreadystatechange = function() {\n\n            if (request.readyState === 4) {\n\n                var result;\n\n                // Prepare the result, check that it's JSON\n                try {\n\n                    result = JSON.parse(request.responseText);\n                } catch(e) {\n\n                    return callback(errors.invalidResponse(e));\n                }\n\n                if (result.status === \"FINISHED\") {\n\n                    var attachedTrytes = result.attachToTangleResponse.trytes;\n                    clearInterval(newInterval);\n\n                    return callback(null, attachedTrytes);\n\n                }\n                else if (result.status === \"FAILED\") {\n\n                    clearInterval(newInterval);\n                    return callback(new Error(\"Sandbox transaction processing failed. Please retry.\"))\n                }\n            }\n        }\n\n        try {\n            request.open('GET', job, true);\n            request.send(JSON.stringify());\n        } catch(error) {\n\n            return callback(new Error(\"No connection to Sandbox, failed with job: \", job));\n        }\n\n    }, 5000)\n\n}\n\n/**\n*   prepares the returned values from the request\n*\n*   @method prepareResult\n*   @param {string} result\n*   @param {function} callback\n**/\nmakeRequest.prototype.prepareResult = function(result, requestCommand, callback) {\n\n    // Result map of the commands we want to format\n    var resultMap = {\n        'getNeighbors'          :   'neighbors',\n        'addNeighbors'          :   'addedNeighbors',\n        'removeNeighbors'       :   'removedNeighbors',\n        'getTips'               :   'hashes',\n        'findTransactions'      :   'hashes',\n        'getTrytes'             :   'trytes',\n        'getInclusionStates'    :   'states',\n        'attachToTangle'        :   'trytes',\n        'wereAddressesSpentFrom':   'states',\n        'checkConsistency'      :   'state'\n    }\n\n    var error;\n\n    try {\n        result = JSON.parse(result);\n    } catch(e) {\n        error = errors.invalidResponse(result);\n        result = null;\n    }\n\n    //\n    //    TODO: PREPARE ERROR MESSAGES BETTER\n    //\n    if (!error && result.error) {\n        error = errors.requestError(result.error);\n        result = null;\n    }\n\n    if (!error && result.exception) {\n        error = errors.requestError(result.exception);\n        result = null;\n    }\n\n    // If correct result and we want to prepare the result\n    if (result && resultMap.hasOwnProperty(requestCommand)) {\n\n        // If the response is from the sandbox, don't prepare the result\n        if (requestCommand === 'attachToTangle' && result.hasOwnProperty('id')) {\n\n            result = result;\n        } else {\n\n            result = result[resultMap[requestCommand]];\n        }\n    }\n\n    return callback(error, result);\n}\n\n\nmodule.exports = makeRequest;\n",null]}