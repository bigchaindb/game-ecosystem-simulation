/*eslint-env node */
'use strict';

//
// This code will be called everytime a job is going to be processed if the job has a repeat option. (from delay -> active).
//
var _ = require('lodash');
var parser = require('cron-parser');
var Job = require('./job');

function nextJob(queue, name, data, opts, isRepeat) {
  console.error(name, data, opts, isRepeat);
  var repeat = opts.repeat;
  if (!isRepeat && opts.jobId) {
    opts.repeat.jobId = opts.jobId;
  }
  var repeatJobId = opts.repeat.jobId ? opts.repeat.jobId + ':' : '';
  var repeatKey = name + ':' + repeatJobId + repeat.cron;

  //
  // Get millis for this repeatable job.
  // Only use `millis` from the `repeatKey` when the job is a repeat, otherwise, we want
  // `Date.now()` to ensure we try to add the next iteration only
  //
  return getOrAddMillis(queue, repeatKey, isRepeat).then(function(millis) {
    console.error('wht=?', millis);

    var interval = parser.parseExpression(
      repeat.cron,
      _.defaults(
        {
          currentDate: new Date(millis)
        },
        repeat
      )
    );
    var nextMillis;
    try {
      nextMillis = interval.next();
    } catch (e) {
      // Ignore error
    }

    if (nextMillis) {
      nextMillis = nextMillis.getTime();
      var delay = nextMillis - Date.now();

      //
      // Generate unique job id for this iteration.
      //
      var customId = 'repeat:' + name + ':' + repeatJobId + nextMillis;

      //
      // Set key and add job should be atomic.
      //
      return queue.client
        .zadd(queue.toKey('repeat'), nextMillis, repeatKey)
        .then(function() {
          return Job.create(
            queue,
            name,
            data,
            _.extend(_.clone(opts), {
              jobId: customId,
              delay: delay < 0 ? 0 : delay,
              timestamp: Date.now()
            })
          );
        });
    }
  });
}

function getOrAddMillis(queue, repeatKey, isRepeat) {
  if (isRepeat) {
    return queue.client.zscore(queue.toKey('repeat'), repeatKey);
  } else {
    var millis = Date.now();
    return queue.client
      .zadd(queue.toKey('repeat'), millis, repeatKey)
      .then(function() {
        return millis;
      });
  }
}

//
// INVESTIGATE: Seems to be a race condition if two workers add the same repeat job at the same time.
// Both could call zscore and get null, both would try to add a repeat key, the last one will overwrite
// the previous key, but both will succeed creating a new Job, making the job execute twice in this case.
// Solution seems to have a lua script that gets or sets the zscore.
module.exports.nextJob = nextJob;
