'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = safeMerge;
/**
 * Takes a list of object and safely merges their properties into a new object.
 * Throws if any of the objects contain a duplicate key that is also in another object.
 * Does not modify the given objects.
 * @param  {...Object} l Any number of objects to merge
 * @return {Object}      Merged object
 */
function safeMerge() {
    for (var _len = arguments.length, l = Array(_len), _key = 0; _key < _len; _key++) {
        l[_key] = arguments[_key];
    }

    // If the objects submitted in the list have duplicates in their key names,
    // abort the merge and tell the function's user to check his objects.
    if (doesObjectListHaveDuplicates(l)) {
        throw new Error('The objects you submitted for merging have duplicates. Merge aborted.');
    }

    return _extends.apply(undefined, [{}].concat(l));
}

/**
 * Checks a list of objects for key duplicates and returns a boolean
 */
function doesObjectListHaveDuplicates(l) {
    var mergedList = l.reduce(function (merged, obj) {
        return obj ? merged.concat(Object.keys(obj)) : merged;
    }, []);

    // Taken from: http://stackoverflow.com/a/7376645/1263876
    // By casting the array to a Set, and then checking if the size of the array
    // shrunk in the process of casting, we can check if there were any duplicates
    return new Set(mergedList).size !== mergedList.length;
}
module.exports = exports['default'];